{"hash":"e5bf1eed04e22915fe60df772657de15feda3786","data":{"wordPressBlog":{"title":"API Gateway+Lambda+Serverless+TravisでAPI開発のCI/CDパイプラインを構築する","content":"\n<h2 class=\"wp-block-heading\">概要</h2>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter\"><a href=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F65478%2F57914bab-deb6-3058-39c9-a087ace85e9e.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=56710cce024edf43eb9d19515df67982\" target=\"_blank\" rel=\"noreferrer noopener\"><img decoding=\"async\" src=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F65478%2F57914bab-deb6-3058-39c9-a087ace85e9e.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=56710cce024edf43eb9d19515df67982\" alt=\"スクリーンショット 2017-02-21 10.15.16.png\"/></a></figure></div>\n\n\n\n<p>API GatewayとLambdaを使ったAPI開発時のCI/CDについての記事です。<br>僕がnode.jsを普段から使用しているため、解説はnodeがベースになっています。</p>\n\n\n\n<p><a href=\"https://github.com/horike37/serverless-api-integration-test-sample\">https://github.com/horike37/serverless-api-integration-test-sample</a></p>\n\n\n\n<p>ソースはすべてGitHubに上がってますのでそちらもご確認ください。</p>\n\n\n\n<h3 class=\"wp-block-heading\">CIで実施する内容</h3>\n\n\n\n<p>以下の内容をCIとして行うことを考えます。</p>\n\n\n\n<ul><li>ESLintによる構文チェック</li><li>Mocha, Chaiを使用したユニットテスト</li><li>APIをAWSへデプロイしてテストを行うインテグレーションテスト</li></ul>\n\n\n\n<h3 class=\"wp-block-heading\">CDで実施する内容</h3>\n\n\n\n<p>以下のようなルールでデプロイのサイクルを回します。</p>\n\n\n\n<ul><li>Gitのdevelopmentブランチへのpushをテスト環境へのデプロイと想定。<ul><li>構文チェックとユニットテストを実施。</li><li>ビルドが通れば、ServerlessのdevelopmentステージにAPIをデプロイ。</li></ul></li><li>Gitのmasterを最新ソースの集約場所として想定して、pushを実施。<ul><li>構文チェックとユニットテストとインテグレーションテストを実施。</li><li>ビルドが通ってもデプロイは実施しない。</li></ul></li><li>Gitのtagへのpushを本番環境へのデプロイと想定。<ul><li>構文チェックとユニットテストとインテグレーションテストを実施。</li><li>ビルドが通れば、ServerlessのproductionステージにAPIをデプロイ。</li></ul></li></ul>\n\n\n\n<h2 class=\"wp-block-heading\">Continuous Integration</h2>\n\n\n\n<h3 class=\"wp-block-heading\">ESLintによる構文チェック</h3>\n\n\n\n<p><a href=\"http://eslint.org/\">http://eslint.org/</a></p>\n\n\n\n<p>JavaScript界隈ではもっともメジャーな構文チェックツールだと思います。構文ルールを定義して、構文エラーや記法を統一させることでソースの可読性や品質を向上させます。</p>\n\n\n\n<p><a href=\"https://github.com/horike37/serverless-api-integration-test-sample/blob/master/.eslintrc.js#L2\">https://github.com/horike37/serverless-api-integration-test-sample/blob/master/.eslintrc.js#L2</a></p>\n\n\n\n<p>今回はルールとしてArbnbを採用しました。どの構文ルールを採用するかはチームの好みで決めれば良いと思います。</p>\n\n\n\n<h3 class=\"wp-block-heading\">Mocha, Chaiを使用したユニットテスト</h3>\n\n\n\n<p>単体テストを実施します。メソッドや関数毎に入力値と出力値をチェックして関数単位での品質チェックを行います。</p>\n\n\n\n<p><a href=\"https://github.com/horike37/serverless-api-integration-test-sample/tree/master/lib\">https://github.com/horike37/serverless-api-integration-test-sample/tree/master/lib</a></p>\n\n\n\n<p>このようにLambdaがメインで実行する部分から、ビジネスロジックをclassに切り出してあげるとテストが書きやすくなるのでそうすることが多いです。</p>\n\n\n\n<h3 class=\"wp-block-heading\">APIをAWSへデプロイしたテストを行うインテグレーションテスト</h3>\n\n\n\n<p>インテグレーションテストはサーバレスアーキテクチャの特徴とも言えるテストです。</p>\n\n\n\n<p>サーバレスアーキテクチャは複数のサービスで構成されているケースが多く、ユニットテストだけではアーキテクチャ全体のテストを網羅できません。実際のクラウド環境へリソースをデプロイして結合テストを行い、すべて成功すれば、それを破棄します。</p>\n\n\n\n<p>このデプロイ管理にはServerlessを使用しています。</p>\n\n\n\n<p><a rel=\"noreferrer noopener\" href=\"https://github.com/horike37/serverless-api-integration-test-sample/blob/master/integration-test/test.js#L18\" target=\"_blank\">https://github.com/horike37/serverless-api-integration-test-sample/blob/master/integration-test/test.js#L18</a><br><a rel=\"noreferrer noopener\" href=\"https://github.com/horike37/serverless-api-integration-test-sample/blob/master/integration-test/test.js#L41\" target=\"_blank\">https://github.com/horike37/serverless-api-integration-test-sample/blob/master/integration-test/test.js#L41</a><br>テストの最初と最後にアーキテクチャのデプロイと削除を行っています。このメソッドの実体は、<code>sls deploy</code>や<code>sls remove</code>です。</p>\n\n\n\n<pre class=\"wp-block-code language-js\"><code>it('should return correct values from all apis', () => {\n     const testEndpoint = `${endpoint}/hello`;\n\n     return fetch(testEndpoint, { method: 'GET' })\n       .then(response => response.json())\n       .then((json) => expect(json.message).to.equal('Go Serverless v1.0! Your function executed successfully!'));\n  });</code></pre>\n\n\n\n<p><a href=\"https://github.com/horike37/serverless-api-integration-test-sample/blob/master/integration-test/test.js#L35-L37\">https://github.com/horike37/serverless-api-integration-test-sample/blob/master/integration-test/test.js#L35-L37</a></p>\n\n\n\n<p>そしてここがテストのメインの部分です。デプロイされたAPIへリクエストを送り、その返り値をchaiでチェックを行います。こうすることで何本APIを作ったとしても自動テストが可能になるというメリットがあります。</p>\n\n\n\n<h2 class=\"wp-block-heading\">Continuous Delivery</h2>\n\n\n\n<h3 class=\"wp-block-heading\">デプロイスクリプト</h3>\n\n\n\n<p>以下の様なスクリプトでデプロイを実施します。Gitのtagにpushされた際にproduction環境へ。Gitのdevelopmentブランチにpushされた際にdeployment環境へ。それぞれビルドが正しく通ればデプロイされるようになっています。bin/deploy.sh</p>\n\n\n\n<pre class=\"wp-block-code language-ssh\"><code>#!/bin/bash\nset -e\nBRANCH=${TRAVIS_BRANCH:-$(git rev-parse --abbrev-ref HEAD)}\nif &#91;&#91; $TRAVIS_TAG ]]; then\n  STAGE=\"production\"\nelif &#91;&#91; $BRANCH == 'development' ]]; then\n  STAGE=\"development\"\nfi\n\nif &#91; -z ${STAGE+x} ]; then\n  echo \"Not deploying changes\";\n  exit 0;\nfi\n\necho \"Deploying from branch $BRANCH to stage $STAGE\"\nnpm prune --production  #remove devDependencies\nsls deploy --stage $STAGE --region $AWS_REGION</code></pre>\n\n\n\n<h3 class=\"wp-block-heading\">ServerlessのIAM権限</h3>\n\n\n\n<p>TravisにてServerlessが動作するように専用のユーザを発行します。今回は最低限で以下の様なIAMポリシーを与えています。</p>\n\n\n\n<pre class=\"wp-block-code language-json\"><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": &#91;\n        {\n            \"Sid\": \"Stmt543534534\",\n            \"Effect\": \"Allow\",\n            \"Action\": &#91;\n                \"iam:GetRole\",\n                \"iam:CreateRole\",\n                \"iam:DeleteRole\",\n                \"iam:PutRolePolicy\",\n                \"iam:DeleteRolePolicy\",\n                \"iam:PassRole\",\n                \"logs:*\",\n                \"s3:*\",\n                \"lambda:*\",\n                \"cloudformation:*\",\n                \"apigateway:*\"\n            ],\n            \"Resource\": &#91;\n                \"*\"\n            ]\n        }\n    ]\n}</code></pre>\n\n\n\n<p>そして、TravisからAWSリソースへアクセスするためにcredentialをTravisへ設定します。<br>もちろん生のcredentialを.travis.ymlへ追記することはご法度です。</p>\n\n\n\n<p>Travisのコマンドにより暗号化し、credentialがTravisの環境上でしか使えないようにします。</p>\n\n\n\n<pre class=\"wp-block-code language-ssh\"><code>$ travis encrypt AWS_ACCESS_KEY_ID=xxxxxxxxxxx --add\n$ travis encrypt AWS_SECRET_ACCESS_KEY=xxxxxxxxxxx --add</code></pre>\n\n\n\n<p>このコマンドにより。.travis.ymlに暗号化した状態でcredentialが設定されます。<br>これはTravis上でビルドを実行した際に環境変数として設定されます。</p>\n\n\n\n<h2 class=\"wp-block-heading\">Travisの設定ファイル</h2>\n\n\n\n<p>最終的にはこんな感じに.travis.ymlが仕上がりました。</p>\n\n\n\n<pre class=\"wp-block-code language-yaml\"><code>travis.yml\n\nlanguage: node_js\nnode_js:\n  - '4.3'\nenv:\n  global:\n    - AWS_REGION=us-east-1\n    - SLS_DEBUG=true\n    - secure: lSxO7tZ0c/FA8VL72042dqQZ+tRjsS93iVYxMr1ghP/0tBxdmrhhYdAD9UrSv/Kk+Y1jRlkpQ2uaARHoy+6ZqmhchX32HpIYBQVJ/ntMSgv37gFbrNTOfSFoATMTRy6RT2UKaIWAa4xnmDxaQNFPx4X5l9Y25RdivoR+WXrEPd4eCCTVL/23bABSIySSTs+VGqQIppE4Jw5ibbcSoTLsuj00nK+VrmYHNlTSiEuKIxgFC1Ix0hqayJ/kely0DqYW/CY/vCCf0V4yazJo9fG1EFfrHsSIAKKeGRY7WMnLPJ7hJGwRiVV1/atMx/5kRPKOADcRTfoh3noXS3/sd1hbGjTwnJVRVrYiUocHwuNbo1TpW1On85jXEdvnKY9JYelFEnXnWn6A2bRMhgL/zul/WuSPCGq7HpsGMRhXrEiEYJ9YhnVNiUTaV2amoOClMOpHFnStMfTJVg7NJ8mBF4XOzODvhAzyPFDWdJ94Ejl1LAnGOAp/wBQVbFswKPdwdosFU6LyirQkA4k0q7C4zXYywyQtrY7H9w7FtKo+U4596GQAQtvzQz6GS42c1WBX0fIrMu1VXc+KmwCUBEVmvBxLS7c0DJUI61atDFGq7788K7IMWw83lIFjJULdwv1qU4uBi3MvPm2OHCdRAzBGEYIC87zfcYI/gi41rh3bj/C0wiI=\n    - secure: LIh0lkl/t72EbMd47WgEXqnoG3REp+oPhIfDR5Cs8SMO4sacvo2j4pRkRKIwwpdKozxdgLEMl1rwDoHyYPH77FzvDnwiufpaYgQs278wmi+6ZvoC9nhgdn2sT7cFnYuYAO8dC7G/NHzXogAVmiObf3I+hzNLjDqWwWVjqPm41p4P4c2EJUVo0nVlcaUOf8elS1j6zp+ZL1EQo4Fm4IumDgNpZUP4bSq8CcVPvF0ynMlslI8XNMnBOiYmG+644qILScyPK1Q2SPdMLqL5YXHuYfE0aCpFcWOcNZIalBmaxPqFNW+QHQvaYiwoENx/i91KS3U2mqfcNYY4o9viih47PFsaddvtBeB83Wfls7GIZ/XmvBKREuS5Gwhz930DbAvUNQT1ylS9Y6TTIIWIbe3Qmv6ngd9TrDHlnbVhQYgar9ur+TgvLyhs5YLAeLn85c3Z3GYN5JUuCq5bclzh4I+myagaWJPoujS1nT+vKLUW8hu5MkxApn+uFUo/OIW1WG4qho/ddh7RoJbI9oTebWjpXhLwd1pSET1yBVSEetORluh0pW7r5A425Rm80B58Mg/x0NNmM1x6DBrCZ5R8d+Bam6C7P4WxxrRex7vFcqRWeKlJNINO+rtPW3Uuo/s9yC9980uQ00eY0kqhouR8ol6xs/4Xye1AHovPR2unzEe37fM=\nbefore_install:\n  - chmod +x ./bin/deploy.sh\n  - npm i -g serverless@1.6.1\ninstall:\n  - travis_retry npm install\nscript:\n  - npm run lint\n  - npm run test\n  - if &#91;&#91; $TRAVIS_BRANCH == \"master\" ]] || &#91;&#91; $TRAVIS_TAG ]]; then npm run integration-test; fi\nafter_success:\n  - cat ./coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js &amp;&amp; rm -rf ./coverage\n  - ./bin/deploy.sh\n﻿</code></pre>\n\n\n\n<h2 class=\"wp-block-heading\">実行結果</h2>\n\n\n\n<h3 class=\"wp-block-heading\">developmentブランチへのpush</h3>\n\n\n\n<p><a href=\"https://travis-ci.org/horike37/serverless-api-integration-test-sample/builds/203491545\">https://travis-ci.org/horike37/serverless-api-integration-test-sample/builds/203491545</a></p>\n\n\n\n<p>ESLintとユニットテストのビルドが成功し、developmentステージへデプロイされています。</p>\n\n\n\n<h3 class=\"wp-block-heading\">masterブランチへのpush</h3>\n\n\n\n<p><a href=\"https://travis-ci.org/horike37/serverless-api-integration-test-sample/builds/203489525\">https://travis-ci.org/horike37/serverless-api-integration-test-sample/builds/203489525</a></p>\n\n\n\n<p>ESLintとユニットテストとインテグレーションテストが成功しましたが、デプロイはされていません。</p>\n\n\n\n<h3 class=\"wp-block-heading\">tagへのpush</h3>\n\n\n\n<p><a href=\"https://travis-ci.org/horike37/serverless-api-integration-test-sample/builds/203484838\">https://travis-ci.org/horike37/serverless-api-integration-test-sample/builds/203484838</a></p>\n\n\n\n<p><code>0.1</code>というタグにpushをしています。<br>ESLintとユニットテストとインテグレーションテストが成功し、puroductionステージにデプロイされています。</p>\n\n\n\n<p>如何でしたでしょうか。こんな感じでCI/CDパイプラインを構築することですべてが自動化され品質も担保されるようになりました。よろしければ是非参考にしてみてください！</p>\n\n\n\n<p>では、良いパイプラインライフを！</p>\n\n\n\n<h2 class=\"wp-block-heading\">参考文献</h2>\n\n\n\n<p><a href=\"http://qiita.com/motchi0214/items/aceca576edf358cd988e\">CodePipelineでServerless Frameworkのデプロイを管理する</a></p>\n","author":{"name":"Takahiro Horike","description":"Co-founder and CEO of Serverless Operations, Inc","avatars":{"avatar96":"https://secure.gravatar.com/avatar/2ee9db3a5b6c492acf66ec14c8a5d8dc?s=96&d=mm&r=g"},"acf":{"userJpName":"堀家 隆宏","userRole":"CEO","facebook":"https://www.facebook.com/horike.takahiro","twitter":"https://twitter.com/horike37","github":"https://github.com/horike37"}},"date":"2017.02.21","path":"/blog/18/","featuredMedia":{"sourceUrl":"https://cdn.getshifter.co/f6642def64a63651c07142605e040674c5441f6d/uploads/2017/02/https___qiita-image-store.s3.amazonaws.com_0_65478_57914bab-deb6-3058-39c9-a087ace85e9e.png","altText":"","mediaDetails":{"width":800}},"categories":[{"id":"7","title":"Blog","path":"/category/blog/"}],"tags":[{"id":"9","title":"API Gateway","path":"/tag/api-gateway/"},{"id":"10","title":"Lambda","path":"/tag/lambda/"},{"id":"2","title":"Serverless","path":"/tag/serverless/"}]},"metadata":{"siteName":"Serverless Operations","siteDescription":"Serverless Operationsは、これまでグローバルの第一線で培ってきたクラウド技術（AWS − アマゾンウェブサービス）の豊富な実績と知見を活かし、お客さまのサーバーレスによる開発や運用の支援、コンサルティングまで一貫してサポート。サーバーレスに関するさまざまな課題を解決いたします。","siteUrl":"https://serverless.co.jp","siteOgImage":"https://serverless.co.jp/ogp.png"}},"context":{}}