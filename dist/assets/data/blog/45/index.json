{"hash":"7f941d81843b6b274431cd2b599fad9eb656e895","data":{"wordPressBlog":{"title":"AWS Lambdaのユニットテストのベストプラクティス(Node.js)","content":"\n<h2 class=\"wp-block-heading\">概要</h2>\n\n\n\n<p>みなさん、テスト書いてますかーー！<br>AWS Lambdaはサーバーレスアーキテクチャを構成する上で、重要なサービスです。そして、その特性上、ユニットテストを書いて変更に強いコードにすることが、継続的なメンテナンスや改善を行っていく上で非常に重要なものとなります。</p>\n\n\n\n<p>この記事は、まずローカルで行うLambdaのユニットテストについてその具体的な手法を書いています。なお、ベストプラクティスってタイトルにしてますが、これはベストプラクティスのひとつであり、その要件ややりたいことや個人的な趣味趣向によって変わってくるということは理解してるので、ひとつのやり方としてみなさんの参考になればと思っています。</p>\n\n\n\n<h2 class=\"wp-block-heading\">テスト対象のLambdaとその要件</h2>\n\n\n\n<p>では、まず初めにテスト対象となるLambdaファンクションの要件を以下のように定義してみます。これを元にしてテストを書きつつその流れを解説したいと思います。</p>\n\n\n\n<h3 class=\"wp-block-heading\">要件</h3>\n\n\n\n<p>まずは今回の要件です。DynamoDBに以下のBlogテーブルが存在していたとしましょう。</p>\n\n\n\n<figure class=\"wp-block-table\"><table><thead><tr><th>key</th><th>用途</th></tr></thead><tbody><tr><td>post_id</td><td>記事ID(ハッシュキー)</td></tr><tr><td>post_title</td><td>タイトル</td></tr><tr><td>post_content</td><td>本文</td></tr></tbody></table></figure>\n\n\n\n<p>以下のような実装を行いたいと考えてみます。<br>&#8211; post_idがLambdaへの外部からの入力値となる<br>&#8211; post_idを元にBlogテーブルを検索して、該当のpost_titleとpost_contentを取得する<br>&#8211; post_titleとpost_contentを返す</p>\n\n\n\n<h4 class=\"wp-block-heading\">処理の流れ</h4>\n\n\n\n<p>この処理の流れをフローチャートにすると以下のようになります。<br><a href=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F65478%2F86b4d71d-1583-0e01-b2c9-0cd85406d9ca.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=17a2fb0da65b95868261df8e2a3c29cd\" target=\"_blank\" rel=\"noreferrer noopener\"></a></p>\n\n\n\n<h3 class=\"wp-block-heading\">テストのパターン</h3>\n\n\n\n<p>まずは、どういったテストを網羅する必要があるのかを考えてみます。上記のフローチャートを見ながら、正常系と異常系に分けて考えてみましょう。</p>\n\n\n\n<p>以下のようなパターンが考えられると思います。</p>\n\n\n\n<h4 class=\"wp-block-heading\">正常系</h4>\n\n\n\n<ul><li>post_idが渡され、Blogテーブルから検索したデータを返した</li></ul>\n\n\n\n<h4 class=\"wp-block-heading\">異常系</h4>\n\n\n\n<ul><li>Lambdaにpost_idが渡されなかった</li><li>post_idはLambdaに渡されたが、Blogテーブルに該当のデータが無かった</li><li>DynamoDB自体が落ちていて処理されなかった</li></ul>\n\n\n\n<p>では、これからこの4パターンでテストコードを作っていきましょう。</p>\n\n\n\n<h2 class=\"wp-block-heading\">使用するユニットテスト用のライブラリ</h2>\n\n\n\n<p>まずはテストコードを書く前にユニットテストに使用したライブラリを紹介します。<br>Node.jsでテストを書く場合は良く出てくるライブラリですので覚えていて損は無いでしょう。</p>\n\n\n\n<h3 class=\"wp-block-heading\">chai</h3>\n\n\n\n<p><a href=\"http://chaijs.com/\" rel=\"noreferrer noopener\" target=\"_blank\">http://chaijs.com/</a>&nbsp;はJavaScript用のアサーションライブラリです。これを使うことで、期待通りの入力値と出力値になっているか比較して、テストの成否を判定します。</p>\n\n\n\n<h3 class=\"wp-block-heading\">Chai as Promised</h3>\n\n\n\n<p><a href=\"https://github.com/domenic/chai-as-promised\" rel=\"noreferrer noopener\" target=\"_blank\">https://github.com/domenic/chai-as-promised</a>&nbsp;はchaiのPromise用の拡張です。<br>Promiseの状態がどうなっているかを判定します。</p>\n\n\n\n<h3 class=\"wp-block-heading\">Mocha</h3>\n\n\n\n<p><a href=\"https://mochajs.org/\" rel=\"noreferrer noopener\" target=\"_blank\">https://mochajs.org/</a>&nbsp;はテスティングフレームワークライブラリです。テストを書くための枠組みを提供してくれたり、コマンドラインからの実行をサポートしてくれたり、<code>beforeEach()</code>や<code>after()</code>といったテスト前後の定形処理を行う関数を提供してくれたりします。テストを実行するための環境を整えてくれるライブラリです。</p>\n\n\n\n<h3 class=\"wp-block-heading\">proxyquire</h3>\n\n\n\n<p><a href=\"https://github.com/thlorenz/proxyquire\" rel=\"noreferrer noopener\" target=\"_blank\">https://github.com/thlorenz/proxyquire</a>&nbsp;はrequireモジュールをスタブ化して動作を変更します。要はローカルでテストするにあたって、aws-sdkが毎回AWSに接続されてしまってはテストが出来ません。そこでproxyquireを使うことでaws-sdkの処理を書き換え、ローカルでテストが行えるようにします。</p>\n\n\n\n<h3 class=\"wp-block-heading\">sinon</h3>\n\n\n\n<p><a href=\"http://sinonjs.org/\" rel=\"noreferrer noopener\" target=\"_blank\">http://sinonjs.org/</a>&nbsp;はテスト用にスタブやモック、スパイを作ってくれるライブラリです。今回はスパイの用途で使用して、proxyquireでスタブ化されたaws-sdkが仕様にそって呼び出されているかをチェックします。</p>\n\n\n\n<h3 class=\"wp-block-heading\">Istanbul</h3>\n\n\n\n<p><a href=\"https://istanbul.js.org/\" rel=\"noreferrer noopener\" target=\"_blank\">https://istanbul.js.org/</a>&nbsp;はコードのカバレッジ計測をしてくれるライブラリです。例えばif文がひとつ追加されると、単純にテストケースとしては2つのケースに分岐されます。そういった形でソースコードの静的解析を行うことでどの程度全体のテストが網羅されているのかを計測します</p>\n\n\n\n<h2 class=\"wp-block-heading\">メインのソースコード</h2>\n\n\n\n<p>まずは先にLambdaファンクションのソースコードを載せておきます。上記のフローチャートをそのままLambdaに落とし込むと以下のようになります。</p>\n\n\n\n<pre class=\"wp-block-code language-js\"><code>'use strict'\nconst aws = require('aws-sdk')\nconst dynamodb = new aws.DynamoDB.DocumentClient()\n\nmodule.exports.blog = (event, context, callback) => {\n  return Promise.resolve().then(() => {\n    if (!event.post_id) {\n      return Promise.reject(responseBilder(400, {message: 'invalid param'}))\n    }\n\n    const params = {\n      TableName: 'Blog',\n      Key: {\n        post_id: event.post_id\n      }\n    }\n    return dynamodb.get(params).promise()\n  }).then(data => {\n    if (!Object.keys(data).length) {\n      return Promise.reject(responseBilder(404, {message: 'can not find specified post'}))\n    } else {\n      return Promise.resolve(responseBilder(200, {\n        post_title: data.Item.post_title,\n        post_content: data.Item.post_content\n      }))\n    }\n  })\n  .then(result => callback(null, result))\n  .catch(error => callback(error))\n}\n\nconst responseBilder = (statusCode, data) => {\n  return JSON.stringify({\n    statusCode: statusCode,\n    body: data\n  })\n}</code></pre>\n\n\n\n<div class=\"gridsome-highlight\">\n\n\n\n<pre class=\"wp-block-code language-js\"><code>const responseBilder = (statusCode, data) => {\n  return JSON.stringify({\n    statusCode: statusCode,\n    body: data\n  })\n}</code></pre>\n\n\n\n</div>\n\n\n\n<h2 class=\"wp-block-heading\">ローカルで動作させるためのスタブの構築</h2>\n\n\n\n<p>Lambda内ではaws-sdkを使ってAWSリソースにアクセスすることが多くなるかと思います。ローカルでテストを行う場合に毎回AWSリソースにアクセスさせる必要はないため(aws-sdk自体の動作は、このアプリケーションのテストの範疇外)、スタブ化してダミーの値を返しつつ、どういう値で呼ばれたか、テスト内で監視を行うのが良いでしょう。</p>\n\n\n\n<h3 class=\"wp-block-heading\">sinonとproxyquireでaws-sdkをスタブ化する</h3>\n\n\n\n<p>スタブ化するにはproxyquireにてrequireで呼び出されるaws-sdkモジュールをスタブ化した上で、sinonのstubやspyと言ったメソッドで、スタブの呼び出しを監視しながらテストするのがベターです。</p>\n\n\n\n<pre class=\"wp-block-code language-js\"><code>const sinon = require('sinon')\nconst proxyquire = require('proxyquire')\n\nconst proxyDynamoDB = class {\n  get (params) {\n    return {\n      promise: () => {}\n    }\n  }\n}\nconst lambda = proxyquire('./handler', {\n  'aws-sdk': {\n    DynamoDB: {\n      DocumentClient: proxyDynamoDB\n    }\n  }\n})\n\nconst dynamoDbGetStub = sinon.stub(proxyDynamoDB.prototype, 'get')\n.returns({promise: () => {\n  return Promise.resolve({\n    Item: {\n      post_title: 'aa',\n      post_content: 'bb'\n    }\n  })\n}})</code></pre>\n\n\n\n<p>だいたい予想はつくかと思いますが、上記の用に書くと、<code>dynamodb.get</code>はスタブの返り値として指定したJSONを返却してくれます。</p>\n\n\n\n<pre class=\"wp-block-code language-json\"><code>{\n  \"Item\": {\n    \"post_title\": \"aa\",\n    \"post_content\": \"bb\"\n  }\n}</code></pre>\n\n\n\n<h3 class=\"wp-block-heading\">疑似Lambdaを実行させるための設定</h3>\n\n\n\n<p>テストを実行するために擬似的にローカルでLambdaを実行させる仕組みを用意します。<br>以下がLambdaファンクションのメイン部分なので、これを動かせるようにダミーの引数を与えれば良いということになります。</p>\n\n\n\n<pre class=\"wp-block-code language-js\"><code>module.exports.blog = (event, context, callback) => {\n}</code></pre>\n\n\n\n<p>以下の用に引数を定義しましょう。<code>context</code>は今回使用してないので、<code>{}</code>を指定しています。使用している場合は以下のドキュメントを参考にダミーの値を設定しましょう。<br><a href=\"http://docs.aws.amazon.com/ja_jp/lambda/latest/dg/nodejs-prog-model-context.html\" rel=\"noreferrer noopener\" target=\"_blank\">http://docs.aws.amazon.com/ja_jp/lambda/latest/dg/nodejs-prog-model-context.html</a></p>\n\n\n\n<p>また、<code>callback</code>にはPromiseを返すようにしていますが、これはテストの結果をPromiseで返えるようにして、値の検査をやりやすくしているためです。</p>\n\n\n\n<pre class=\"wp-block-code language-js\"><code>const event = {\n  post_id: 'your-post-id'\n}\nconst callback = (error, result) => {\n  return new Promise((resolve, reject) => {\n    error ? reject(error) : resolve(result)\n  })\n}\nconst context = {}</code></pre>\n\n\n\n<h2 class=\"wp-block-heading\">テストの実装</h2>\n\n\n\n<p>では、それぞれのテストを実装していきましょう。<br>テストのパターンは上記の4つです。それぞれのパターンに分けて解説していきます。</p>\n\n\n\n<h3 class=\"wp-block-heading\">post_idが渡され、Blogテーブルから検索したデータを返した</h3>\n\n\n\n<p>Promiseの状態が<code>fulfilled</code>になっていること、DynamoDBのgetが1回実行されたこと、正常系の返り値が返ってきたことをテストしています。</p>\n\n\n\n<pre class=\"wp-block-code language-js\"><code>it('Should return resolve when running successfully', () => {\n  return expect(lambda.blog(event, context, callback)).to.be.fulfilled.then(result => {\n    expect(dynamoDbGetStub.calledOnce).to.be.equal(true)\n    expect(result).to.deep.equal(JSON.stringify({\n      statusCode: 200,\n      body: {post_title: 'aa', post_content: 'bb'}\n    }))\n  })\n})</code></pre>\n\n\n\n<h3 class=\"wp-block-heading\">Lambdaにpost_idが渡されなかった</h3>\n\n\n\n<p>先ほど、post_idをセットしていた<code>event</code>を空オブジェクトで上書きします。<br>そしてPromiseの結果がrejectedになっていること、入力チェックで落ちたためにDynamoDBが呼ばれなかったこと、異常系の返り値が返ってきたことをテストしています。</p>\n\n\n\n<pre class=\"wp-block-code language-js\"><code>it('Should return reject when post_id is not given', () => {\n  event = {}\n  return expect(lambda.blog(event, context, callback)).to.be.rejected.then(result => {\n    expect(dynamoDbGetStub.calledOnce).to.be.equal(false)\n    expect(result).to.deep.equal(JSON.stringify({\n      statusCode: 400,\n      body: {message: 'invalid param'}\n    }))\n  })\n})\n﻿</code></pre>\n\n\n\n<h3 class=\"wp-block-heading\">post_idはLambdaに渡されたが、Blogテーブルに該当のデータが無かった</h3>\n\n\n\n<p>dynamoDbGetStubの返り値にデータが取得できなかった時の<code>{}</code>が変えるようにスタブを設定します。そして、異常系の返り値が返ってきたことをテストしています。</p>\n\n\n\n<pre class=\"wp-block-code language-js\"><code>it('Should return reject when you can not your item in DB', () => {\n  dynamoDbGetStub = sinon.stub(proxyDynamoDB.prototype, 'get')\n  .returns({promise: () => {\n    return Promise.resolve({})\n  }})\n  return expect(lambda.blog(event, context, callback)).to.be.rejected.then(result => {\n    expect(dynamoDbGetStub.calledOnce).to.be.equal(true)\n    expect(result).to.deep.equal(JSON.stringify({\n      statusCode: 404,\n      body: {message: 'can not find specified post'}\n    }))\n  })\n})</code></pre>\n\n\n\n<h3 class=\"wp-block-heading\">DynamoDB自体が落ちていて処理されなかった</h3>\n\n\n\n<p>dynamoDbGetStubがrejectedされるようにスタブを設定します。</p>\n\n\n\n<pre class=\"wp-block-code language-js\"><code>it('Should return reject when error occurs in DB', () => {\n  dynamoDbGetStub = sinon.stub(proxyDynamoDB.prototype, 'get')\n  .returns({promise: () => {\n    return Promise.reject('error')\n  }})\n  return expect(lambda.blog(event, context, callback)).to.be.rejected.then(result => {\n    expect(dynamoDbGetStub.calledOnce).to.be.equal(true)\n    expect(result).to.be.equal('error')\n  })\n})</code></pre>\n\n\n\n<h2 class=\"wp-block-heading\">テストの実行</h2>\n\n\n\n<p>package.jsonにて以下のような設定を行いカバレッジの計測とテストの実行を<code>npm run test</code>で行えるようにします。</p>\n\n\n\n<pre class=\"wp-block-code language-json\"><code>\"scripts\": {\n  \"test\": \"istanbul cover -x 'handler.test.js' node_modules/mocha/bin/_mocha 'handler.test.js' -- -R spec --recursive\"\n}</code></pre>\n\n\n\n<p>実行結果は以下のとおりです。<br>4つともテストは成功して、カバレッジも100%問題なくテストできていることがわかります。<br><a href=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F65478%2Fafc1fd38-5370-c43c-2cab-fc4abfb530f5.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=a7e9738d7a7ca342ecd204272eba7031\" target=\"_blank\" rel=\"noreferrer noopener\"></a></p>\n\n\n\n<h2 class=\"wp-block-heading\">まとめ</h2>\n\n\n\n<p>今回解説したものは以下のGitHubにあげておりますので、興味のある方は確認してみてください<br><a href=\"https://github.com/horike37/lambda-unittest-sample\" rel=\"noreferrer noopener\" target=\"_blank\">https://github.com/horike37/lambda-unittest-sample</a></p>\n\n\n\n<p>如何でしたでしょうか。ぜひこれを参考にTest Driven Deveropment for Lambdaを実践していってもらえればと思います！</p>\n","author":{"name":"Takahiro Horike","description":"Co-founder and CEO of Serverless Operations, Inc","avatars":{"avatar96":"https://secure.gravatar.com/avatar/2ee9db3a5b6c492acf66ec14c8a5d8dc?s=96&d=mm&r=g"},"acf":{"userJpName":"堀家 隆宏","userRole":"CEO","facebook":"https://www.facebook.com/horike.takahiro","twitter":"https://twitter.com/horike37","github":"https://github.com/horike37"}},"date":"2017.06.30","path":"/blog/45/","featuredMedia":{"sourceUrl":"https://cdn.getshifter.co/f6642def64a63651c07142605e040674c5441f6d/uploads/2017/06/AWS-Lambda_dark-bg@4x.png","altText":"","mediaDetails":{"width":300}},"categories":[{"id":"7","title":"Blog","path":"/category/blog/"}],"tags":[{"id":"10","title":"Lambda","path":"/tag/lambda/"},{"id":"16","title":"ユニットテスト","path":"/tag/e3-83-a6-e3-83-8b-e3-83-83-e3-83-88-e3-83-86-e3-82-b9-e3-83-88/"}]},"metadata":{"siteName":"Serverless Operations","siteDescription":"Serverless Operationsは、これまでグローバルの第一線で培ってきたクラウド技術（AWS − アマゾンウェブサービス）の豊富な実績と知見を活かし、お客さまのサーバーレスによる開発や運用の支援、コンサルティングまで一貫してサポート。サーバーレスに関するさまざまな課題を解決いたします。","siteUrl":"https://serverless.co.jp","siteOgImage":"https://serverless.co.jp/ogp.png"}},"context":{}}