{"hash":"35053359aff549c8e1d81009f00eae950570ae45","data":{"wordPressBlog":{"title":"AWSにおけるAPI開発にてGraphQL(AppSync)とREST API(API Gateway) を選定する際のメリットとデメリット","content":"\n<p>最近何かと話題になってきた GraphQL ですが、AWS では AppSync という GraphQL サービスがあります。2018年リリースされて以来、サーバーレスコミュニティの中でも年々関心が高まっており、実例も増えてきています。GraphQL は、主流となった REST と比べるとまだ新しい技術と言えますが、この度 Costless の開発で実際に採用してみて、どのような利点と大変さがあったか、整理しておきたいと思います。</p>\n\n\n\n<h2 class=\"wp-block-heading\">おさらい</h2>\n\n\n\n<p>本題に入る前に、冒頭で触れている REST, GrapgQL, また AWS の GraphQL サービスである AppSync について簡単に触れておきます。</p>\n\n\n\n<h3 class=\"wp-block-heading\">REST API</h3>\n\n\n\n<p>Web API を定義するためのアーキテクチャスタイルで、データの送受信はステートレスになること、対象のリソースを URI として一位に識別できるように表現すること、HTTP メソッドを利用してそのリソースに対する操作を定義することが原則となります。これにより、API定義の一貫性が保たれ、クライアントとのステートレスなデータの送受信、統合的なインタフェースを作りやすくなるといったメリットがあります。</p>\n\n\n\n<h3 class=\"wp-block-heading\">GraphQL</h3>\n\n\n\n<p>従来の Web API より効率的かつフレキシブルなアプローチができることで知られているクエリー言語です。すべての操作が一つのエンドポイントを通して実現でき、予め送受信するデータのスキーマを定義しておく必要があります。これにより、クライアントサイドから柔軟にクエリができるようになります。また、一般的なデータの取得と更新に加えて、リアルタイムに通知のやり取りができる仕様 Subscription が含まれています。</p>\n\n\n\n<h3 class=\"wp-block-heading\">AppSync</h3>\n\n\n\n<p>2018年にリリースされた、AWS のサーバーレスな GraphQL サービスです。 GraphQL スキーマを定義し、Lambda や DynamoDB といった AWS サービスをデータソースとするシームレスな連携ができたり、AWS Amplify と組み合わせてオンライン／オフラインのデータ同期ができるといった特徴があります。</p>\n\n\n\n<h2 class=\"wp-block-heading\">Costless で AppSync / GraphQL を選定した背景</h2>\n\n\n\n<p>弊社ではサーバーレスに特化したコスト管理サービス「Costless」をリリースしました。この Costless を開発するにあたって、Costless 自体も AWS サーバーレスアーキテクチャで構成されていますが、弊社開発チームではそれに加え以下のような理由でバックエンドに AppSync を全面的に採用することにしました。</p>\n\n\n\n<ul><li>顧客の AWS アカウントと Costless を連携する際に CloudFormation Custom Resources を使う必要があり、CloudFormation の展開が完了したことをリアルタイムでフロントエンドへ通知する必要があった</li><li>通知を受けたいのは自分がセットしたものだけで、複数ユーザー間や双方向のやり取りは不要（API Gateway の Websocket ではオーバースペック）</li><li>AppSync/GraphQL が話題になることが増えていることも鑑み、新しい技術を使うチャンスと捉える</li></ul>\n\n\n\n<figure class=\"wp-block-image size-large\"><img decoding=\"async\" loading=\"lazy\" width=\"949\" height=\"1024\" src=\"https://cdn.getshifter.co/f6642def64a63651c07142605e040674c5441f6d/uploads/2021/01/Costless_AWS_Architecture-949x1024.png\" alt=\"\" class=\"wp-image-325\" srcset=\"https://cdn.getshifter.co/f6642def64a63651c07142605e040674c5441f6d/uploads/2021/01/Costless_AWS_Architecture-949x1024.png 949w, https://cdn.getshifter.co/f6642def64a63651c07142605e040674c5441f6d/uploads/2021/01/Costless_AWS_Architecture-278x300.png 278w, https://cdn.getshifter.co/f6642def64a63651c07142605e040674c5441f6d/uploads/2021/01/Costless_AWS_Architecture-768x829.png 768w, https://cdn.getshifter.co/f6642def64a63651c07142605e040674c5441f6d/uploads/2021/01/Costless_AWS_Architecture.png 1001w\" sizes=\"(max-width: 949px) 100vw, 949px\" /></figure>\n\n\n\n<h2 class=\"wp-block-heading\">AppSync を使ってみて、REST で作る場合と比べてみる</h2>\n\n\n\n<p>それでは、実際 Costless のバックエンドを AppSync/GraphQL メインで実装してみて分かったところについて、慣れ親しんだ REST と比較して良かったところ・大変だったところを紹介します。</p>\n\n\n\n<h3 class=\"wp-block-heading\">良かったところ</h3>\n\n\n\n<h4 class=\"wp-block-heading\">① GraphQL スキーマ定義によるバリデーション</h4>\n\n\n\n<p>文字列や数字といった基本的なデータ型のバリデーションについては、GraphQL スキーマで定義した通りのデータ型によりチェックされるため、個別に行う必要はありません。</p>\n\n\n\n<p>REST の場合は仕様ドキュメントレベルで各データ項目の型を定義し、実装に反映する必要があります。また、そういった定義を書くための Open API といった仕組みは充実してきていますが、実装とドキュメントが分離している状況に変わりはなく、大規模になっていくに連れて双方の整合性を維持・管理することがペインポイントとなることもあります。</p>\n\n\n\n<pre class=\"wp-block-code language-graphql\"><code>type User {\n  id: ID!\n  name: String!\n  email: AWSEmail!\n  version: Int!\n}\ninput UpdateUserInput {\n  name: String!\n  email: AWSEmail!\n  version: Int!\n}</code></pre>\n\n\n\n<p>※スキーマに合っていないデータが送受信される場合はエラーになる</p>\n\n\n\n<h4 class=\"wp-block-heading\">② Subscription を使ったリアルタイム通知の手軽さ</h4>\n\n\n\n<p>リアルタイム通知に関しては API Gateway の Websocket で実装することも可能ですが、そういった手間を書けることなくシンプルに実現できる手軽さがあります。</p>\n\n\n\n<pre class=\"wp-block-code language-graphql\"><code>type Subscription {\n  onCreateProject(id: ID!): CreateProjectResult @aws_subscribe(mutations: &#91;\"createProject\"])\n}\ntype Mutation {\n  createProject(input: CreateProjectInput!): CreateProjectResult!\n}\ntype CreateProjectByCfnResult {\n  id: ID!\n  name: String!\n  version: Int!\n}</code></pre>\n\n\n\n<pre class=\"wp-block-preformatted\"></pre>\n\n\n\n<p>※プロジェクト作成が完了したら呼び出し元（フロントエンド）へ通知が出される</p>\n\n\n\n<h4 class=\"wp-block-heading\">③ AppSync からの DynamoDB CRUD操作が便利</h4>\n\n\n\n<p>AppSync で受けたリクエストは、Lambda を介さずとも、VTL（Apache Velocity Template Language）というテンプレート言語を使ってシームレスに DynamoDB などの他のサービスと連携することが可能です。ただ、これについては仕様が複雑になるについて最も辛くなるところでもありますので悩ましい部分もあります。</p>\n\n\n\n<pre class=\"wp-block-code language-velocity\"><code>#set($userId = \"user#$context.identity.sub\")\n{\n  \"version\": \"2018-05-29\",\n  \"operation\": \"GetItem\",\n  \"key\": {\n    \"id\": $util.dynamodb.toDynamoDBJson($userId)\n  }\n}</code></pre>\n\n\n\n<pre class=\"wp-block-preformatted\"></pre>\n\n\n\n<h3 class=\"wp-block-heading\">大変だったところ</h3>\n\n\n\n<p>AppSync では、GraphQL スキーマで定義した項目の値を解決するためのリゾルバーの設定に、前述の VTL というテンプレート言語を書く必要があります。DynamoDB へのCRUD操作といった簡単なケースでは問題にならないですが、例えばデータにアクセスするための権限チェックや条件分岐が発生するようなケースでは、テンプレート言語であるがゆえに複雑でテストがしづらくなります。</p>\n\n\n\n<pre class=\"wp-block-code language-velocity\"><code>## Note: this logic exists in aaa.response.vtl...\n## Check all files when the logic is modified.\n#set($project = $context.result)\n#if($project.status == \"STATUS-1\")\n  #set($status = \"STATUS-1\")\n#elseif($project.status == \"STATUS-2\")\n  #set($status = \"STATUS-2\")\n  #set($now = $util.time.nowEpochMilliSeconds())\n  #if($now &lt; $project.date)\n    #set($status = \"STATUS-3\")\n  #end\n#elseif($project.status == \"STATUS-4\")\n  #set($status = \"STATUS-4\")\n#end</code></pre>\n\n\n\n<pre class=\"wp-block-preformatted\"></pre>\n\n\n\n<p>こうした背景から頑張って VTL を書く代わりに AWS CDK や Direct Lambda Resolver を採用するといった方法はありますが、Costless チームではなるべく AppSync を使い倒す意図である程度 VTL と向き合って開発を進めてきました。これに関しては、定番の API Gateway + Lambda + DynamoDB 構成の REST にしていたら、きちんと仕様を詰めてさえいれば特に問題とならないでしょう。</p>\n\n\n\n<h2 class=\"wp-block-heading\">まとめ</h2>\n\n\n\n<ul><li>「Costless」のバックエンド開発に AppSync/GraphQLを採用</li><li>AppSync/GraphQLを使うと、GraphQLのスキーマ定義によりAPI定義と入力チェックが一元管理でき、Subscriptionを使って通知機能を手軽に管理できるといったメリットがある</li><li>一方、AppSync でリゾルバーを設定するにはVTLを書かなければならず、仕様が複雑になっていくに連れてペインポイントとなりやすい</li></ul>\n","author":{"name":"Sonu Kim","description":"","avatars":{"avatar96":"https://secure.gravatar.com/avatar/5b527696e38c84c34048954d767b1537?s=96&d=mm&r=g"},"acf":{"userJpName":"金 仙優","userRole":"COO","facebook":"","twitter":"","github":""}},"date":"2021.01.12","path":"/blog/324/","featuredMedia":{"sourceUrl":"https://cdn.getshifter.co/f6642def64a63651c07142605e040674c5441f6d/uploads/2020/05/so-release.png","altText":"so-release-image","mediaDetails":{"width":1200}},"categories":[{"id":"7","title":"Blog","path":"/category/blog/"}],"tags":[{"id":"9","title":"API Gateway","path":"/tag/api-gateway/"},{"id":"19","title":"Appsync","path":"/tag/appsync/"}]},"metadata":{"siteName":"Serverless Operations","siteDescription":"Serverless Operationsは、これまでグローバルの第一線で培ってきたクラウド技術（AWS − アマゾンウェブサービス）の豊富な実績と知見を活かし、お客さまのサーバーレスによる開発や運用の支援、コンサルティングまで一貫してサポート。サーバーレスに関するさまざまな課題を解決いたします。","siteUrl":"https://serverless.co.jp","siteOgImage":"https://serverless.co.jp/ogp.png"}},"context":{}}