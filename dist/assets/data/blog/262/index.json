{"hash":"35053359aff549c8e1d81009f00eae950570ae45","data":{"wordPressBlog":{"title":"Amazon API Gateway の Custom Authorizerを使い、User PoolsのユーザでAPI認証を行う","content":"\n<h1 class=\"wp-block-heading\">概要</h1>\n\n\n\n<p>Amazon API Gateway の Custom Authorizerを使うと、独自の認証をLambdaファンクションで定義して、API Gatewayで作ったAPIのアクセス管理を行うことが出来ます。<br><a href=\"http://docs.aws.amazon.com/ja_jp/apigateway/latest/developerguide/use-custom-authorizer.html#api-gateway-custom-authorization-overview\" rel=\"noreferrer noopener\" target=\"_blank\">Amazon API Gateway カスタム認証の概要</a></p>\n\n\n\n<p>今回はUser Poolsで管理されているユーザでAPI認証機能を作ります。<br>User Poolsについては<a href=\"http://qiita.com/horike37/items/1d522f66452d3abe1203\">Amazon Cognito User Poolsを使って、webサイトにユーザ認証基盤を作る</a>で詳しく書いています。</p>\n\n\n\n<figure class=\"wp-block-image\"><a href=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F65478%2F9dd9947f-32d9-6646-be39-b763003de91d.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=15c9dfb971a51dd79c7d8b2076d4647d\" target=\"_blank\" rel=\"noreferrer noopener\"><img decoding=\"async\" src=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F65478%2F9dd9947f-32d9-6646-be39-b763003de91d.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=15c9dfb971a51dd79c7d8b2076d4647d\" alt=\"custom-auth-workflow.png\"/></a></figure>\n\n\n\n<p>端的に言うとUser Poolsで管理のユーザ情報でAPIを認証しようということです。単純にユーザログインが必要で会員情報をやり取りするアプリには非常に効果的に使うことが出来ると思います。</p>\n\n\n\n<h2 class=\"wp-block-heading\">認証用のLambdaファンクション</h2>\n\n\n\n<p>APIへのリクエスト時にAuthorizationヘッダを受け取ります。AuthorizationヘッダーにUser Poolsのアクセストークンをセットしてリクエストを送信します。</p>\n\n\n\n<p><code>cognitoidentityserviceprovider.getUser</code>メソッドで判定を行い。<br>エラーが返れば、API Gatewayに返すPolicy DocumentにDenyを通知。正しくユーザ情報が返れば、Allowを通知します。</p>\n\n\n\n<pre class=\"wp-block-code language-js\"><code>const aws = require( 'aws-sdk' )\nconst cognitoidentityserviceprovider = new aws.CognitoIdentityServiceProvider({apiVersion: '2016-04-18',region: 'us-east-1'})\n\nexports.handler = function(event, context) {\n  const params = {\n    AccessToken:event.authorizationToken\n  }\n  cognitoidentityserviceprovider.getUser(params, function(err, data) {\n    if (err) { \n      context.succeed(generatePolicy('user', 'Deny', event.methodArn))\n    } else {\n      context.succeed(generatePolicy(data.Username, 'Allow', event.methodArn))\n    }\n  })\n}\n\nconst generatePolicy = function(principalId, effect, resource) {\n  const authResponse = {}\n  authResponse.principalId = principalId\n  if (effect &amp;&amp; resource) {\n    const policyDocument = {}\n    policyDocument.Version = '2012-10-17'\n    policyDocument.Statement = &#91;]\n    const statementOne = {}\n    statementOne.Action = 'execute-api:Invoke'\n    statementOne.Effect = effect\n    statementOne.Resource = resource\n    policyDocument.Statement&#91;0] = statementOne\n    authResponse.policyDocument = policyDocument\n  }\n  return authResponse\n}</code></pre>\n\n\n\n<pre class=\"wp-block-preformatted\"></pre>\n\n\n\n<p>以下の設定画面で<code>method.request.header.Authorization</code>を設定することで、Lambdaファンクション内の<code>event.authorizationToken</code>で送られてきたアクセストークンが取得できます。<br><a href=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F65478%2Ffe8d431d-aa36-828e-d7ba-c69b09b69996.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=08714a1d4dc124a25f2e3c562867835d\" target=\"_blank\" rel=\"noreferrer noopener\"></a></p>\n\n\n\n<p>認証を通過すると以下の様なPolicy Documentが返り、APIのバックエンド処理が実行されます。</p>\n\n\n\n<pre class=\"wp-block-code language-json\"><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": &#91;\n    {\n      \"Action\": \"execute-api:Invoke\",\n      \"Effect\": \"Allow\",\n      \"Resource\": \"arn:aws:execute-api:ap-northeast-1:&lt;Account ID>:5j2z5a7nh9/null/GET/\"\n    }\n  ]\n}</code></pre>\n\n\n\n<pre class=\"wp-block-preformatted\"></pre>\n\n\n\n<h2 class=\"wp-block-heading\">認証されたユーザ情報をバックエンドのLambdaファンクションに渡す</h2>\n\n\n\n<p>認証を通ったのはいいのですが、通常は認証済みのユーザ情報をAPIのバックエンドのLambdaファンクションでも取得して処理を行いたいと思います。その時は<code>principalId</code>を使用します。</p>\n\n\n\n<p><code>$context.authorizer.principalId</code>をマッピングさせることで認証時にprincipalIdに指定した値をバックエンドで使用することが可能です。</p>\n\n\n\n<figure class=\"wp-block-image\"><a href=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F65478%2F36d1c1e6-6233-767f-367c-f8e5f202767e.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=ae4f64dded792dc7832ea5f0f1d82f58\" target=\"_blank\" rel=\"noreferrer noopener\"><img decoding=\"async\" src=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F65478%2F36d1c1e6-6233-767f-367c-f8e5f202767e.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=ae4f64dded792dc7832ea5f0f1d82f58\" alt=\"スクリーンショット 2016-05-06 1.10.00.png\"/></a></figure>\n\n\n\n<p>バックエンドのLambdaファンクションは以下のようにマッピングさせた値を単純に返すものを今回はセットしました。</p>\n\n\n\n<pre class=\"wp-block-code language-js\"><code>exports.handler = (event, context, callback) => {\n    callback(null, event.email); \n};</code></pre>\n\n\n\n<pre class=\"wp-block-preformatted\"></pre>\n\n\n\n<h2 class=\"wp-block-heading\">実行</h2>\n\n\n\n<p>これでデプロイしたAPIを叩いてみましょう</p>\n\n\n\n<p>何もヘッダを指定しない状態だと、401が返ってきます。</p>\n\n\n\n<pre class=\"wp-block-code language-bash\"><code>&#91;horike@horiketakahiro-no-MacBook-Pro Documents]$curl --include https://5j2z5a7nh9.execute-api.ap-northeast-1.amazonaws.com/v1\n\n\nHTTP/1.1 401 Unauthorized\nContent-Type: application/json\nContent-Length: 26\nConnection: keep-alive\nDate: Thu, 05 May 2016 16:17:37 GMT\nx-amzn-ErrorType: UnauthorizedException\nx-amzn-RequestId: e23e564b-12dc-11e6-8e7a-099c2c59ca1e\nX-Cache: Error from cloudfront\nVia: 1.1 5753ad031d92fdc94452799736f8b898.cloudfront.net (CloudFront)\nX-Amz-Cf-Id: oKcZn-6iyF7rcQ-LNYW696m-WYwTwm6kIsXPyyW8eTN8gXwf_hbciA==\n\n{\"message\":\"Unauthorized\"}</code></pre>\n\n\n\n<pre class=\"wp-block-preformatted\"></pre>\n\n\n\n<p>次にAuthorizationヘッダにでたらめな値を付けると、認証に弾かれて403が返ってきます。</p>\n\n\n\n<pre class=\"wp-block-code language-bash\"><code>&#91;horike@horiketakahiro-no-MacBook-Pro Documents]$curl --include https://5j2z5a7nh9.execute-api.ap-northeast-1.amazonaws.com/v1 -H 'Authorization: aaaaaaa'\n\n\nHTTP/1.1 403 Forbidden\nContent-Type: application/json\nContent-Length: 60\nConnection: keep-alive\nDate: Thu, 05 May 2016 16:19:05 GMT\nx-amzn-ErrorType: AccessDeniedException\nx-amzn-RequestId: 15fa82a2-12dd-11e6-9ffc-5bd6f26ab516\nX-Cache: Error from cloudfront\nVia: 1.1 b5af8e55f6a9cb57b52430dc88fed3be.cloudfront.net (CloudFront)\nX-Amz-Cf-Id: DT9Kdk7YpaAMkn_GFzXdh4T7oNlKao87pQOqCc_wfs3DqNeQGaWOVQ==\n\n{\"Message\":\"User is not authorized to access this resource\"}</code></pre>\n\n\n\n<pre class=\"wp-block-preformatted\"></pre>\n\n\n\n<p>最後にAuthorizationヘッダに正しいアクセストークンを付与すると以下の用にちゃんと意図通りの結果が返ってきました。</p>\n\n\n\n<pre class=\"wp-block-code language-bash\"><code>&#91;horike@horiketakahiro-no-MacBook-Pro Documents]$curl --include https://5j2z5a7nh9.execute-api.ap-northeast-1.amazonaws.com/v1 -H 'Authorization: eyJraWQiOiJMK1luaTlURkR1Snl3UHJDdnNLVnJRVk1iREE1WkhHZ0tHdjZGRnRsdHhRPSIsImFsZyI6IlJTMjU2In0.eyJzdWIiOiIzYjNlMWU5My01NmUwLTQ2ODgtYTYzMi0yMjdiYjdlZTAwZjEiLCJ0b2tlbl91c2UiOiJdhY2Nlc3MiLCJzY29wZSI6ImF3cy5jb2duaXRvLnNpZ25pbi51c2VyLmFkbWluIiwiaXNzIjoiaHR0cHM6XC9cL2NvZ25pdG8taWRwLnVzLWVhc3QtMS5hbWF6b25hd3MuY29tXC91cy1lYXN0LTFfaXFMa2hvRFNXIiwiZXhwIjoxNDYyNDY4ODg1LCJjbGllbnRfaWQiOiIzbmppbXBxMnBhaXVlNG9mbms1bDRyOWYwdSIsInVzZXJuYW1lIjoiaG9yaWtlKzAwNUBkaWdpdGFsY3ViZS5qcCJ9.nNKEmvsosVpQM0w74Z-ruTSkyssTseI4xM2TvDxG9BEyz1bxsZhE1L14JHtKK9FXsKUYlAXAAblnkDdswSRlvge9UNmh6uPMgLUYA6jL-aZX3CNemgDHTZc0JxnsuaIF4WqnJ8T2gHtC-tCmIjUkJILIoPxMCPneklBO1rIjBEt2MQ2HBkYmkz3yfqVeE603Vr29yf3pcOpn-OcRvDq58UDr4liWI7ZR71ehgLhqmFv-qQ-_Kp6iInsUnK681nR2gvVXe1KMXKc6y5mwngBncocbx2gnqbXsyp_qQ4p93dTA6f_6CzMMeiPVVT9bK7m3pUsDASNWQhEdfbN_FZUdYksw'\n\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\nContent-Length: 37\nConnection: keep-alive\nDate: Thu, 05 May 2016 16:22:06 GMT\nx-amzn-RequestId: 817a58ed-12dd-11e6-8b94-0d04b870f135\nX-Cache: Miss from cloudfront\nVia: 1.1 dbd66f9b48a662a90decd25d25e606f5.cloudfront.net (CloudFront)\nX-Amz-Cf-Id: H9AyM6Xcs1goT341YENCsGcytUEb8BlONA6oWfo8nTLdwYVjszYkJg==\n\n{\"email\":\"horike+005@digitalcube.jp\"}\n</code></pre>\n\n\n\n<pre class=\"wp-block-preformatted\"></pre>\n\n\n\n<p>こんなに簡単にUser Poolsを使ってAPI Gatewayにユーザ認証の機能を付与することが出来ました。<br>ますます実用的になっていきますね！</p>\n","author":{"name":"Takahiro Horike","description":"Co-founder and CEO of Serverless Operations, Inc","avatars":{"avatar96":"https://secure.gravatar.com/avatar/2ee9db3a5b6c492acf66ec14c8a5d8dc?s=96&d=mm&r=g"},"acf":{"userJpName":"堀家 隆宏","userRole":"CEO","facebook":"https://www.facebook.com/horike.takahiro","twitter":"https://twitter.com/horike37","github":"https://github.com/horike37"}},"date":"2017.05.13","path":"/blog/262/","featuredMedia":{"sourceUrl":"https://cdn.getshifter.co/f6642def64a63651c07142605e040674c5441f6d/uploads/2020/05/so-release.png","altText":"so-release-image","mediaDetails":{"width":1200}},"categories":[{"id":"7","title":"Blog","path":"/category/blog/"}],"tags":[{"id":"9","title":"API Gateway","path":"/tag/api-gateway/"},{"id":"32","title":"UserPool","path":"/tag/userpool/"}]},"metadata":{"siteName":"Serverless Operations","siteDescription":"Serverless Operationsは、これまでグローバルの第一線で培ってきたクラウド技術（AWS − アマゾンウェブサービス）の豊富な実績と知見を活かし、お客さまのサーバーレスによる開発や運用の支援、コンサルティングまで一貫してサポート。サーバーレスに関するさまざまな課題を解決いたします。","siteUrl":"https://serverless.co.jp","siteOgImage":"https://serverless.co.jp/ogp.png"}},"context":{}}