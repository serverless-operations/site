{"hash":"35053359aff549c8e1d81009f00eae950570ae45","data":{"wordPressBlog":{"title":"エンタープライズなAWSサーバーレスアプリケーションを構成管理する時の方法と考え方","content":"\n<h2 class=\"wp-block-heading\">概要</h2>\n\n\n\n<p>AWSでサーバーレスアーキテクチャでアプリケーションを構築する際、多くの場合はたくさんのLambdaやフルマネージドサービスで構成されることになります。その際にどういったディレクトリ構成でどのようにソースコードを構成してCI/CDを回していけばよいかをこの記事では書いています。</p>\n\n\n\n<p>結論としては、<a href=\"https://github.com/serverless-operations/serverless-enterprise-application-boilerplate-for-python\" rel=\"noreferrer noopener\" target=\"_blank\">Serverless Enterprise Application Boilerplate For Python</a>に実際のソースコードとしてまとめていますので、より詳細はこちらを確認してもらえればと思います。</p>\n\n\n\n<h2 class=\"wp-block-heading\">使用しているサービスとツール</h2>\n\n\n\n<p>本記事ではCI環境としてCircleCIを使っています。GitHub ActionsやCodeBuildでも同じようなことが可能なはずなので、これらは好みで選べば良いでしょう。</p>\n\n\n\n<p>また、デプロイツールとしてServerless Frameworkを使っています。SAMでもCDKでも大体同じことは可能なので、どれを選ぶかは好みを最優先して良いでしょう。</p>\n\n\n\n<p>以降、これらのデプロイツールを使うと最終的にはCloudFormationに展開されるので、CloudFormationの前提で記述します。</p>\n\n\n\n<h2 class=\"wp-block-heading\">アプリケーション内部でサービスを分割しよう</h2>\n\n\n\n<p>冒頭でも述べたとおり、エンタープライズなアプリケーションになるとたくさんのAWSサービスを構成管理する必要があります。それをひとつのファイルで管理するのは流石に無理があるため、細かくサービスの単位に分割して構成管理をするようにします。分割した単位でCloudFormationの1スタックがデプロイされるイメージです。</p>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter\"><a href=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F65478%2F8c340426-2aa6-94e1-469d-1684569d9809.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=7c108f849d6de6847591547768086518\" target=\"_blank\" rel=\"noreferrer noopener\"><img decoding=\"async\" src=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F65478%2F8c340426-2aa6-94e1-469d-1684569d9809.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=7c108f849d6de6847591547768086518\" alt=\"Untitled (2).png\"/></a></figure></div>\n\n\n\n<p>まずポイントとしてはステートを持つサービスと持たないサービスを明確に分離します。DynamoDBやS3のようなデータを永続化させるサービスとLambdaのようにデータを永続化しないサービスは当然デプロイのサイクルも頻度も違います。それらが違うものは明確に分離させたほうがいいでしょう。</p>\n\n\n\n<p>そしてアプリケーションの入り口となるAPI達は1つのスタックにしてしまいます。残りのバックエンドで処理をしてくれるものは処理として完結できる意味のある単位で分けるのが良いでしょう。そしてそれぞれのバックエンドサービス間で値のやり取りが発生するケースも多いと思うので、どのようにそれらのサービス間でデータを受け渡しするのかも考えておきましょう。</p>\n\n\n\n<p>具体的に考えられるデータの受け渡し方法は以下のとおりです。</p>\n\n\n\n<ul><li>EventBridgeやSQSにデータをPublishして引き継ぐ</li><li>DBに値を入れておいて、別のサービスからデータをポーリングして受け取る</li><li>API Gatewayでhttpエンドポイントを用意してそこにデータを渡す</li><li>S3を使用してのファイル連携</li></ul>\n\n\n\n<h2 class=\"wp-block-heading\">ディレクトリ構成</h2>\n\n\n\n<p><a href=\"https://github.com/serverless-operations/serverless-enterprise-application-boilerplate-for-python\" rel=\"noreferrer noopener\" target=\"_blank\">Serverless Enterprise Application Boilerplate For Python</a>を見てもらえるとわかるかと思いますが、以下のようなルールでディレクトリ構成を決めます</p>\n\n\n\n<figure class=\"wp-block-table\"><table><thead><tr><th>ディレクトリ</th><th>用途</th></tr></thead><tbody><tr><td>layer</td><td>Lambda Layerとしてデプロイする外部のライブラリや共通処理として定義したコードを参照先としてlayerとなるCloudFormationを定義します。</td></tr><tr><td>resources</td><td>DynamoDBやS3、SSMなどデータを保持するサービスのCloudFormationを定義します。</td></tr><tr><td>lib</td><td>共通処理として定義したコードを定義します。これらはLambda Layerとしてデプロイします。</td></tr><tr><td>services</td><td>1つ前のセクションで分割した各サービスを格納します。1サービス1CloudFormationスタックの単位で定義していきます。</td></tr><tr><td>tests</td><td>テストコードを格納します。ユニットテストとインテグレーションテストが主に入ります。</td></tr></tbody></table></figure>\n\n\n\n<h2 class=\"wp-block-heading\">サービス間での値の参照</h2>\n\n\n\n<p>細かくサービスやリソースの単位でCloudformationを分割するので、当然ながらDBのTable名やArnの値は複数のサービスから参照させる必要があります。</p>\n\n\n\n<p>その場合はCloudFormationの<a href=\"https://docs.aws.amazon.com/ja_jp/AWSCloudFormation/latest/UserGuide/outputs-section-structure.html\" rel=\"noreferrer noopener\" target=\"_blank\">クロススタック出力</a>やServerless Frameworkであれば、<a href=\"https://www.serverless.com/framework/docs/providers/aws/guide/variables#reference-cloudformation-outputs\" rel=\"noreferrer noopener\" target=\"_blank\">Reference CloudFormation Outputs</a>の機能を使うことでスタック間で値を参照できます。</p>\n\n\n\n<p>なので、外部のスタックから参照させたい値はCloudFormationのOutPutsに出力して参照できるようにしておきましょう。</p>\n\n\n\n<p>CloudFormationの<a rel=\"noreferrer noopener\" href=\"https://docs.aws.amazon.com/ja_jp/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-importvalue.html\" target=\"_blank\">ImportValue</a>の機能を使えば以下の様に書くことで値が参照できます。 </p>\n\n\n\n<pre class=\"wp-block-code language-yaml\"><code>Fn::ImportValue: &lt;Export名></code></pre>\n\n\n\n<p>また、Serverless Frameworkの機能を使うと以下のように記述できます </p>\n\n\n\n<pre class=\"wp-block-code language-ssh\"><code>${cf.&lt;リージョン名>:&lt;CloudFormationスタック名>.&lt;output名>}\n\ntableArn: ${cf.ap-northeast-1:dev-stack.tableArn}</code></pre>\n\n\n\n<h2 class=\"wp-block-heading\">テストの方針</h2>\n\n\n\n<p>サーバーレスアプリケーションを作る上での多くのケースではユニットテストとインテグレーションテストの2パターンを行います。</p>\n\n\n\n<p>ユニットテストは通常のアプリケーションで実行するユニットテストです。インテグレーションテストは実際にAWS環境にデプロイしてその実行結果をテストします。</p>\n\n\n\n<p>インテグレーションテストを必ず行うことがサーバーレスアプリケーションでは特徴的かもしれません。どうしても分散型のアプリケーションではユニットテストだけではテストをやりきることが難しいです。実際にユニットテストが通ってもIAMの設定が足りずに動かないかもしれません。そういったクラウド独自の仕組みも含めて処理が完了することを確認するためにインテグレーションテストを行います。</p>\n\n\n\n<p>基本的には正常系を1パターン以上インテグレーションテストを記述します。そして内部的なバリデーション等のロジックをユニットテストでカバーするのが良いでしょう。</p>\n\n\n\n<p>例えばAPIのインテグレーションテストのCIの設定例を見てみましょう。「Deploy API for integration test」のフェーズでAWS環境に必要なリソースをデプロイします。その後「Run API integration test」で実際にAWS上で期待通りの動作をするかのテストを行います。 </p>\n\n\n\n<pre class=\"wp-block-code language-yaml\"><code>  api_test:\n    executor:\n      name: default\n    steps:\n      - attach_workspace:\n          at: ~/workspace\n      - run: *install_sls\n      - run:\n          name: Deploy API for integration test\n          command: |\n            . venv/bin/activate\n            yarn deploy:db\n            yarn deploy:layer\n            yarn deploy:api\n          environment:\n            STAGE: 1\n      - run:\n          name: Run API integration test\n          command: |\n            . venv/bin/activate\n            yarn test:api\n          environment:\n            STAGE: 1</code></pre>\n\n\n\n<h2 class=\"wp-block-heading\">AWSアカウントの分け方</h2>\n\n\n\n<p>サーバーレスアプリケーションでなくてもこれは同様かと思いますが、本番とそれ以外の環境でアカウントを分離します。</p>\n\n\n\n<p>本番でないアカウントの方では各開発者ごとの環境とステージングの環境が存在します。Serverless FrameworkであればStageの機能を使ってこれらの環境を切り分けるのが良いでしょう。そして、本番とそれ以外のデプロイ先の切り替えはCircleCIのContextの機能を使います。</p>\n\n\n\n<p>この機能を使えば条件に応じて適用する環境変数のセットを切り替えることが出来るので、それを利用してアカウントの切り替えを行います。</p>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter\"><a href=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F65478%2Ff528a480-dc5a-a1e3-2571-74328bb52cfb.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=4725b3b70c77c0d68c0d45598f027cfc\" target=\"_blank\" rel=\"noreferrer noopener\"><img decoding=\"async\" src=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F65478%2Ff528a480-dc5a-a1e3-2571-74328bb52cfb.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=4725b3b70c77c0d68c0d45598f027cfc\" alt=\"accounts.png\"/></a></figure></div>\n\n\n\n<h2 class=\"wp-block-heading\">CI/CDパイプライン</h2>\n\n\n\n<p>ステージング及び本番についてはCI環境から自動デプロイを行います。以下のような条件で自動デプロイを設定します。</p>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter\"><a href=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F65478%2Fcadda769-352c-d271-86fb-085aa0aec837.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=d82d7ac8ea9e8f306e1040b50c9d73c1\" target=\"_blank\" rel=\"noreferrer noopener\"><img decoding=\"async\" src=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F65478%2Fcadda769-352c-d271-86fb-085aa0aec837.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=d82d7ac8ea9e8f306e1040b50c9d73c1\" alt=\"Untitled (1).png\"/></a></figure></div>\n\n\n\n<p>以下は具体的にmasterブランチにマージされた際のCircleCIのワークフローになります。<br><a href=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F65478%2Fd3e01c16-81ca-4789-b42f-0cc736c7f6e3.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=fedb744ae5c8d54a4e1f5e9cde3a21a7\" target=\"_blank\" rel=\"noreferrer noopener\"></a></p>\n\n\n\n<figure class=\"wp-block-image\"><a href=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F65478%2Fd3e01c16-81ca-4789-b42f-0cc736c7f6e3.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=fedb744ae5c8d54a4e1f5e9cde3a21a7\" target=\"_blank\" rel=\"noreferrer noopener\"><img decoding=\"async\" src=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F65478%2Fd3e01c16-81ca-4789-b42f-0cc736c7f6e3.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=fedb744ae5c8d54a4e1f5e9cde3a21a7\" alt=\"スクリーンショット 2020-05-11 8.54.15.png\"/></a></figure>\n\n\n\n<p>以下のような順でワークフローを定義しています。<br>1. 環境のセットアップ<br>2. Lintによる構文チェック<br>3. ユニットテスト<br>4. インテグレーションテスト<br>5. ステージングへのデプロイ</p>\n\n\n\n<h2 class=\"wp-block-heading\">まとめ</h2>\n\n\n\n<p>以上でディレクトリ構成からテストやデプロイまでの方針の考え方を述べてきました。<br>このようにすることで複数のスタックから構成される大規模なサーバーレスアプリケーションでもスッキリと構成管理を行って運用することが出来ます。<br>是非皆さんもこれを参考にサーバーレスアーキテクチャの導入にチャレンジしてもらえるとうれしいです。</p>\n","author":{"name":"Takahiro Horike","description":"Co-founder and CEO of Serverless Operations, Inc","avatars":{"avatar96":"https://secure.gravatar.com/avatar/2ee9db3a5b6c492acf66ec14c8a5d8dc?s=96&d=mm&r=g"},"acf":{"userJpName":"堀家 隆宏","userRole":"CEO","facebook":"https://www.facebook.com/horike.takahiro","twitter":"https://twitter.com/horike37","github":"https://github.com/horike37"}},"date":"2020.05.11","path":"/blog/26/","featuredMedia":{"sourceUrl":"https://cdn.getshifter.co/f6642def64a63651c07142605e040674c5441f6d/uploads/2020/05/https___qiita-image-store.s3.ap-northeast-1.amazonaws.com_0_65478_8c340426-2aa6-94e1-469d-1684569d9809.png","altText":"","mediaDetails":{"width":816}},"categories":[{"id":"7","title":"Blog","path":"/category/blog/"}],"tags":[{"id":"8","title":"AWS","path":"/tag/aws/"},{"id":"2","title":"Serverless","path":"/tag/serverless/"}]},"metadata":{"siteName":"Serverless Operations","siteDescription":"Serverless Operationsは、これまでグローバルの第一線で培ってきたクラウド技術（AWS − アマゾンウェブサービス）の豊富な実績と知見を活かし、お客さまのサーバーレスによる開発や運用の支援、コンサルティングまで一貫してサポート。サーバーレスに関するさまざまな課題を解決いたします。","siteUrl":"https://serverless.co.jp","siteOgImage":"https://serverless.co.jp/ogp.png"}},"context":{}}