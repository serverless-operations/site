{"hash":"899a7dadc9c3ff481284dbd8cf731b9f93beffd5","data":{"wordPressBlog":{"title":"サーバーレスアーキテクチャでリアルタイムランキングAPIを作る","content":"\n<h2 class=\"wp-block-heading\">概要</h2>\n\n\n\n<p><a href=\"https://www.wwdjapan.com/\" rel=\"noreferrer noopener\" target=\"_blank\">WWDJAPAN</a>というメディアのお仕事を手伝ってまして、そこでリアルタイムにサイトへのアクセス数をカウントしてランキングを表示する仕組みをAWSで作った(まだ、サイト側には公開していませんが)のでそれの仕組みとかコードを共有したいと思います。</p>\n\n\n\n<p>ちなみにGoogle AnalyticsのリアルタイムAPIを使う方法もあるのですが、APIの使用申請をGoogleに送ったところ、何故かスルーされてしまったので独自に作る方針としました。</p>\n\n\n\n<h2 class=\"wp-block-heading\">アーキテクチャ</h2>\n\n\n\n<p>APIとして以下の2つ必要になります。そしてバックエンドにはKinesisをおいてアクセスデータをバッファさせる仕組みです。<br>&#8211; サイトのPVを収集するためのAPI<br>&#8211; ランキングの結果を取得するAPI(WebSocketにしても面白いと思う)</p>\n\n\n\n<figure class=\"wp-block-image\"><a href=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F65478%2F4a21b576-125c-6971-f052-f4a67b4fe8b9.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=d54c593c3e93bc9abe7d79c8e5696178\" target=\"_blank\" rel=\"noreferrer noopener\"><img decoding=\"async\" src=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F65478%2F4a21b576-125c-6971-f052-f4a67b4fe8b9.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=d54c593c3e93bc9abe7d79c8e5696178\" alt=\"Realtime Ranking (1).png\"/></a></figure>\n\n\n\n<h3 class=\"wp-block-heading\">PV収集用API</h3>\n\n\n\n<p>API GatewayとKinesis StreamをAWS Service Proxyの機能を使って直接接続します。<br>このAPIはサイトの記事詳細ページに埋め込んで、ページが表示するたびにその記事IDをRanking Consumer　Streamに対して記事IDをPutします。</p>\n\n\n\n<p>ここのシャード数はサイトからの同時接続数によって変わってくるので、実際に埋め込んでみて調整するのが良いでしょう。<br>そして、Ranking Consumerの背後にいるLambdaでRanking Collector Streamにシャード毎のデータをまとめてPutします。</p>\n\n\n\n<p>Ranking Collector Streamのシャードは1本固定にしています。これはランキング取得APIから1本のシャードに対してデータをGetすることで集計をしやすくするという意図があります。また、Ranking Consumer Streamのシャードを増減させてもLambda自体のコードには手を加えなくてよいというメリットもあります。</p>\n\n\n\n<h3 class=\"wp-block-heading\">ランキング取得API</h3>\n\n\n\n<p><a href=\"https://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html\" rel=\"noreferrer noopener\" target=\"_blank\">GetShardIterator</a>と<a href=\"https://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetRecords.html\" rel=\"noreferrer noopener\" target=\"_blank\">GetRecords</a>オペレーションで現在時刻から数分前までにputされたデータをKinesisから取り出します。</p>\n\n\n\n<p>以下のように、<code>ShardIteratorType</code>に<code>AT_TIMESTAMP</code>を指定すると指定の時刻以降にシャードにputされたデータのみを取得してくれるので、これを現在時刻から5分前までなどに指定することでリアルタイム性を出しています。</p>\n\n\n\n<pre class=\"wp-block-code language-js\"><code>await aws.request('Kinesis', 'getShardIterator', {\n  ShardId: 'shardId-000000000000',\n  ShardIteratorType: 'AT_TIMESTAMP',\n  StreamName: streamName,\n  Timestamp: dt // ここに指定したタイムスタンプ以降にシャードにputされたデータのみを取得する\n})</code></pre>\n\n\n\n<p>そして以下のようなランキングのJsonを生成してAPI に返却します。ランキング結果</p>\n\n\n\n<pre class=\"wp-block-code language-json\"><code>&#91;\n  {\n    \"post_id\": 795075,\n    \"count\": 58\n  },\n  {\n    \"post_id\": 794978,\n    \"count\": 43\n  },\n  {\n    \"post_id\": 794963,\n    \"count\": 32\n  },\n  {\n    \"post_id\": 754499,\n    \"count\": 25\n  },\n  {\n    \"post_id\": 795236,\n    \"count\": 20\n  },\n  {\n    \"post_id\": 795228,\n    \"count\": 19\n  },\n  {\n    \"post_id\": 795939,\n    \"count\": 18\n  },\n  {\n    \"post_id\": 795021,\n    \"count\": 18\n  },\n  {\n    \"post_id\": 795841,\n    \"count\": 16\n  },\n  {\n    \"post_id\": 793589,\n    \"count\": 15\n  }\n]</code></pre>\n\n\n\n<h2 class=\"wp-block-heading\">構成管理</h2>\n\n\n\n<p>Serverless Frameworkを使用しています。以下がそのserverless.yamlファイルの全貌です。serverless.yml</p>\n\n\n\n<pre class=\"wp-block-code language-yaml\"><code>service: realtime-ranking\n\nprovider:\n  name: aws\n  runtime: nodejs8.10\n  stage: dev\n  region: ap-northeast-1\n\nfunctions:\n  rankingCollector:\n    handler: lambda/apiGateway/rankingCollector.handler\n    events:\n      - http:\n          path: /ranking\n          method: get\n          cors: true\n    environment:\n      MINUITES_OF_RANKING_TERM: 10\n      COUNT_OF_RANKING: 10\n      COLLECTOR_STREAM_NAME: { Ref: 'RankingCollectorStream' }\n    iamRoleStatements:\n      - Effect: Allow\n        Action:\n           - 'kinesis:GetRecords'\n           - 'kinesis:GetShardIterator'\n        Resource: {\"Fn::GetAtt\":&#91; \"RankingCollectorStream\", \"Arn\" ]}\n  rankingConsumer:\n    handler: lambda/kinesisStreams/rankingConsumer.handler\n    events:\n      - stream:\n          type: kinesis\n          batchSize: 1000\n          arn:\n            Fn::GetAtt:\n              - RankingConsumerStream\n              - Arn\n    environment:\n      COLLECTOR_STREAM_NAME: { Ref: 'RankingCollectorStream' }\n    iamRoleStatements:\n      - Effect: Allow\n        Action:\n           - 'kinesis:PutRecord'\n        Resource: {\"Fn::GetAtt\":&#91; \"RankingCollectorStream\", \"Arn\" ]}\ncustom:\n  stage: ${opt:stage, self:provider.stage}\n  apiGatewayServiceProxies:\n    - kinesis:\n        path: /ranking\n        method: post\n        streamName: { Ref: 'RankingConsumerStream' }\n        cors: true\n\nresources:\n  Resources:\n    RankingConsumerStream:\n      Type: AWS::Kinesis::Stream\n      Properties:\n        ShardCount: 3\n        Name: ${self:service}-${self:custom.stage}-ranking-consumer\n    RankingCollectorStream:\n      Type: AWS::Kinesis::Stream\n      Properties:\n        ShardCount: 1\n        Name: ${self:service}-${self:custom.stage}-ranking-collector\nplugins:\n  - serverless-apigateway-service-proxy\n  - serverless-iam-roles-per-function</code></pre>\n\n\n\n<p>今回、KinesisとAPI GatewayをLambdaを挟むことなく直接接続するために、<a href=\"https://github.com/horike37/serverless-apigateway-service-proxy\" rel=\"noreferrer noopener\" target=\"_blank\">Serverless API Gateway Service Proxy</a>というServerless Frameworkのプラグインを開発して公開しました。</p>\n\n\n\n<p>今までであれば、これを実現するために膨大なCloudFormationを記述しないといけなかったのですが、以下のようにたった数行で実現できてしまいます。是非使う機会などあれば、GitHubにスター付けてくれたりフィードバックもらえると嬉しいです。</p>\n\n\n\n<pre class=\"wp-block-code language-yaml\"><code>custom:\n  apiGatewayServiceProxies:\n    - kinesis:\n        path: /ranking\n        method: post\n        streamName: { Ref: 'RankingConsumerStream' }\n        cors: true</code></pre>\n\n\n\n<p>というわけで、みなさまよいリアルタイムランキングライフを！</p>\n","author":{"name":"Takahiro Horike","description":"Co-founder and CEO of Serverless Operations, Inc","avatars":{"avatar96":"https://secure.gravatar.com/avatar/2ee9db3a5b6c492acf66ec14c8a5d8dc?s=96&d=mm&r=g"},"acf":{"userJpName":"堀家 隆宏","userRole":"CEO","facebook":"https://www.facebook.com/horike.takahiro","twitter":"https://twitter.com/horike37","github":"https://github.com/horike37"}},"date":"2020.02.19","path":"/blog/43/","featuredMedia":{"sourceUrl":"https://cdn.getshifter.co/f6642def64a63651c07142605e040674c5441f6d/uploads/2020/02/https___qiita-image-store.s3.amazonaws.com_0_65478_4a21b576-125c-6971-f052-f4a67b4fe8b9.png","altText":"","mediaDetails":{"width":957}},"categories":[{"id":"7","title":"Blog","path":"/category/blog/"}],"tags":[{"id":"13","title":"Kinesis","path":"/tag/kinesis/"},{"id":"11","title":"Serverless Framework","path":"/tag/serverless-framework/"}]},"metadata":{"siteName":"Serverless Operations","siteDescription":"Serverless Operationsは、これまでグローバルの第一線で培ってきたクラウド技術（AWS − アマゾンウェブサービス）の豊富な実績と知見を活かし、お客さまのサーバーレスによる開発や運用の支援、コンサルティングまで一貫してサポート。サーバーレスに関するさまざまな課題を解決いたします。","siteUrl":"https://serverless.co.jp","siteOgImage":"https://serverless.co.jp/ogp.png"}},"context":{}}